import aiohttp
import os
import asyncio
import sqlite3
import time
import random
import threading
from datetime import datetime, timedelta
from typing import List, Dict, Any
import pytz
from dotenv import load_dotenv

from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes

# ------------------ Load environment ------------------
load_dotenv()
BOT_TOKEN = os.getenv("BOT_TOKEN")
TIMEZONE = os.getenv("TIMEZONE", "Africa/Lagos")
DB_PATH = os.getenv("DB_PATH", "trade_data.db")
HTTP_PORT = int(os.environ.get("PORT", 8080))

# ===== FIXED: DIRECTLY INCLUDE YOUR ADMIN ID =====
ADMIN_IDS = [123456789]  # ‚¨ÖÔ∏è REPLACE THIS WITH YOUR ACTUAL NUMERIC ID

print("üîç ENV CHECK:")
print(f" BOT_TOKEN: {'‚úÖ' if BOT_TOKEN else '‚ùå'}")
print(f" TIMEZONE: {TIMEZONE}")
print(f" ADMIN_IDS: {ADMIN_IDS}")
print("--------------------------------------------------")

if not BOT_TOKEN:
    raise RuntimeError("BOT_TOKEN is required in environment variables")

TZ = pytz.timezone(TIMEZONE)

# ------------------ Optimized Settings ------------------
MIN_SIGNAL_COOLDOWN = 60   # 1 minute minimum
MAX_SIGNAL_COOLDOWN = 180  # 3 minutes maximum

# Simple tracking
active_users = set()
user_start_times = {}
approved_users = set(ADMIN_IDS)  # Admins are automatically approved

# ------------------ OPTIMIZED WATCHLIST ------------------
# Major Currency Pairs (Most Liquid)
POCKET_MAJOR_FOREX = [
    "EUR/USD", "GBP/USD", "USD/JPY", "USD/CHF", "AUD/USD", 
    "USD/CAD", "NZD/USD", "EUR/GBP", "EUR/JPY", "GBP/JPY"
]

# Top Cryptocurrencies
POCKET_CRYPTO = [
    "BTC/USD", "ETH/USD", "LTC/USD", "XRP/USD", "BCH/USD",
    "ADA/USD", "DOGE/USD", "SOL/USD", "DOT/USD", "AVAX/USD"
]

# Major Commodities
POCKET_COMMODITIES = [
    "XAU/USD", "XAG/USD", "OIL/USD", "NATURALGAS/USD", "COPPER/USD"
]

# Blue-Chip Stocks
POCKET_STOCKS = [
    "AAPL", "TSLA", "AMZN", "GOOGL", "MSFT",
    "META", "NFLX", "NVDA", "AMD", "INTC"
]

# Combine all watchlists
WATCHLIST = (
    POCKET_MAJOR_FOREX + 
    POCKET_CRYPTO + 
    POCKET_COMMODITIES + 
    POCKET_STOCKS
)

print(f"üìä Total assets in watchlist: {len(WATCHLIST)}")
print(f"üåç Forex: {len(POCKET_MAJOR_FOREX)}")
print(f"‚Çø Crypto: {len(POCKET_CRYPTO)}")
print(f"üí∞ Commodities: {len(POCKET_COMMODITIES)}")
print(f"üè¢ Stocks: {len(POCKET_STOCKS)}")

# ------------------ HTTP health server ------------------
from http.server import HTTPServer, BaseHTTPRequestHandler

class HealthHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        try:
            if self.path in ["/", "/health"]:
                self.send_response(200)
                self.send_header('Content-type', 'text/plain; charset=utf-8')
                self.end_headers()
                self.wfile.write(b"ADMIN TRADING BOT - Live")
            else:
                self.send_response(404)
                self.end_headers()
        except Exception:
            self.send_response(500)
            self.end_headers()
    
    def log_message(self, format, *args):
        return

def start_http_server():
    try:
        server = HTTPServer(("0.0.0.0", HTTP_PORT), HealthHandler)
        print(f"‚úÖ HTTP server listening on port {HTTP_PORT}")
        server.serve_forever()
    except Exception as e:
        print(f"‚ùå HTTP server failed: {e}")

# ------------------ DB (SQLite) ------------------
def init_db(path: str = DB_PATH):
    conn = sqlite3.connect(path, check_same_thread=False)
    cur = conn.cursor()
    cur.execute("""
        CREATE TABLE IF NOT EXISTS signals (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            symbol TEXT,
            side TEXT,
            entry_price REAL,
            confidence REAL,
            label TEXT,
            details TEXT,
            timestamp TEXT,
            status TEXT DEFAULT 'OPEN',
            exit_price REAL,
            exit_time TEXT,
            profit REAL,
            platform TEXT DEFAULT 'PocketOption'
        )
    """)
    cur.execute("""
        CREATE TABLE IF NOT EXISTS subscribers (
            chat_id INTEGER PRIMARY KEY,
            username TEXT,
            status TEXT DEFAULT 'pending',
            join_date TEXT,
            subscription_type TEXT DEFAULT 'premium',
            approved INTEGER DEFAULT 0
        )
    """)
    conn.commit()
    conn.close()
    print("‚úÖ Database initialized")

init_db()

def load_approved_users():
    """Load approved users from database"""
    try:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        cur = conn.cursor()
        cur.execute("SELECT chat_id FROM subscribers WHERE approved = 1")
        approved = {row[0] for row in cur.fetchall()}
        conn.close()
        
        # Add admin IDs to approved users
        approved.update(ADMIN_IDS)
        return approved
    except Exception as e:
        print(f"‚ùå Error loading approved users: {e}")
        return set(ADMIN_IDS)  # Return at least admin IDs

# Load approved users on startup
approved_users = load_approved_users()
print(f"‚úÖ Loaded {len(approved_users)} approved users (including {len(ADMIN_IDS)} admins)")

# ------------------ ADMIN TRADING BOT ------------------
class AdminTradingBot:
    def __init__(self):
        self.session = None
        self.total_signals_sent = 0
        self.user_loops = {}
        
    async def init_session(self):
        try:
            self.session = aiohttp.ClientSession()
            print("‚úÖ Session initialized")
        except Exception as e:
            print(f"‚ùå Session failed: {e}")
            await asyncio.sleep(5)
            await self.init_session()

    def add_user(self, user_id: int, username: str):
        try:
            conn = sqlite3.connect(DB_PATH, check_same_thread=False)
            cur = conn.cursor()
            
            # Check if user already exists
            cur.execute('SELECT approved FROM subscribers WHERE chat_id = ?', (user_id,))
            existing = cur.fetchone()
            
            if existing:
                # User exists, update if needed
                if existing[0] == 0 and user_id in ADMIN_IDS:
                    # This is an admin who wasn't marked as approved
                    cur.execute('UPDATE subscribers SET approved = 1, status = "approved" WHERE chat_id = ?', (user_id,))
                    approved_users.add(user_id)
                    print(f"‚úÖ Admin user {user_id} auto-approved")
            else:
                # New user
                is_approved = 1 if user_id in ADMIN_IDS else 0
                status = "approved" if user_id in ADMIN_IDS else "pending"
                
                cur.execute('INSERT INTO subscribers (chat_id, username, status, join_date, approved) VALUES (?, ?, ?, ?, ?)',
                          (user_id, username, status, datetime.now().isoformat(), is_approved))
                
                if user_id in ADMIN_IDS:
                    approved_users.add(user_id)
                    print(f"‚úÖ Admin user {user_id} registered and auto-approved")
                else:
                    print(f"‚úÖ User added: {user_id} (Pending Approval)")
            
            conn.commit()
            conn.close()
                
        except Exception as e:
            print("Add user error:", e)

    def is_user_approved(self, user_id: int) -> bool:
        """Check if user is approved - admins are always approved"""
        return user_id in approved_users or user_id in ADMIN_IDS

    def is_admin(self, user_id: int) -> bool:
        """Check if user is admin"""
        return user_id in ADMIN_IDS

    def approve_user(self, user_id: int) -> bool:
        """Approve a user"""
        try:
            conn = sqlite3.connect(DB_PATH, check_same_thread=False)
            cur = conn.cursor()
            cur.execute("UPDATE subscribers SET approved = 1, status = 'approved' WHERE chat_id = ?", (user_id,))
            conn.commit()
            conn.close()
            
            approved_users.add(user_id)
            print(f"‚úÖ User {user_id} approved")
            return True
        except Exception as e:
            print(f"‚ùå Error approving user: {e}")
            return False

    def get_all_subscribers(self) -> List[Dict]:
        """Get all subscribers with details"""
        try:
            conn = sqlite3.connect(DB_PATH, check_same_thread=False)
            cur = conn.cursor()
            cur.execute("SELECT chat_id, username, status, join_date, approved FROM subscribers ORDER BY join_date DESC")
            subscribers = []
            for row in cur.fetchall():
                subscribers.append({
                    'chat_id': row[0],
                    'username': row[1] or 'No Username',
                    'status': row[2],
                    'join_date': row[3],
                    'approved': bool(row[4]),
                    'is_admin': row[0] in ADMIN_IDS
                })
            conn.close()
            return subscribers
        except Exception as e:
            print(f"‚ùå Error getting subscribers: {e}")
            return []

    async def safe_send_message(self, user_id: int, application, message: str):
        """Safely send message with error handling"""
        try:
            if user_id in active_users and self.is_user_approved(user_id):
                await application.bot.send_message(
                    chat_id=user_id,
                    text=message,
                    parse_mode='Markdown'
                )
                return True
            return False
        except Exception as e:
            print(f"‚ùå Failed to send message to {user_id}: {e}")
            return False

    def get_next_candle_time(self):
        """Calculate timing for next candle (5-minute candles)"""
        now = datetime.now()
        # Get the start of next 5-minute interval
        next_minute = (now + timedelta(minutes=5)).replace(second=0, microsecond=0)
        seconds_until_next_candle = (next_minute - now).total_seconds()
        
        # Pre-entry at 40 seconds before next candle
        preentry_time = next_minute - timedelta(seconds=40)
        seconds_until_preentry = (preentry_time - now).total_seconds()
        
        return {
            'next_candle_time': next_minute,
            'seconds_until_next_candle': seconds_until_next_candle,
            'seconds_until_preentry': max(seconds_until_preentry, 1)  # At least 1 second
        }

    async def generate_signal(self, symbol: str) -> Dict[str, Any]:
        """Generate signal aligned with new 5-minute candle"""
        try:
            # Get timing for next candle
            timing = self.get_next_candle_time()
            next_candle_time = timing['next_candle_time']
            
            # Format times
            entry_time_str = next_candle_time.strftime("%H:%M")
            current_time_str = datetime.now().strftime("%H:%M:%S")
            
            # Determine direction
            direction = "UP" if random.random() < 0.6 else "DOWN"
            direction_emoji = "üü¢ UP" if direction == "UP" else "üî¥ DOWN"
            
            # Asset type detection
            asset_type = "FOREX"
            if symbol in POCKET_CRYPTO:
                asset_type = "CRYPTO"
            elif symbol in POCKET_COMMODITIES:
                asset_type = "COMMODITY"
            elif symbol in POCKET_STOCKS:
                asset_type = "STOCK"
            
            signal_id = f"SIG-{random.randint(1000, 9999)}"
            confidence = random.randint(78, 89)
            
            # PRE-ENTRY MESSAGE (40 seconds before new candle)
            preentry_message = f"""‚è∞ **PRE-ENTRY ALERT** ‚è∞

üéØ **{symbol}** | **{direction}** | **5M**
üïí **Current Time:** {current_time_str}
‚è∞ **Entry Time:** {entry_time_str} (New 5M Candle)
üìä **Signal Strength:** HIGH

**Prepare for the new 5-minute candle!** üöÄ"""
            
            # MAIN SIGNAL MESSAGE (At new candle)
            signal_message = f"""üéØ **NEW 5M CANDLE SIGNAL** üéØ

üìä **ASSET:** {symbol}
üéØ **DIRECTION:** {direction_emoji}
‚è∞ **TIMEFRAME:** 5 Minutes
üí∞ **PAYOUT:** 80-95%
üîÑ **STRATEGY:** 5-Minute Candle Breakout

‚úÖ **TRADE SETUP:**
‚Ä¢ Entry: New 5M Candle Open
‚Ä¢ Confidence: {confidence}%
‚Ä¢ Risk: Medium
‚Ä¢ Duration: 5 Minutes

üìà **TECHNICALS:**
‚Ä¢ Trading new 5-minute candle formation
‚Ä¢ Optimal entry at candle open
‚Ä¢ Clear directional bias on higher timeframe

üöÄ **EXECUTE NOW:**
1. Open Pocket Option
2. Select {symbol} & 5M
3. Set {direction} at {entry_time_str}
4. Confirm trade

üÜî **ID:** {signal_id}
‚è∞ **Entry:** {entry_time_str} (5M Candle Open)
üìç **Expiry:** 5 Minutes

‚è±Ô∏è **Next signal within 1-3 minutes!**"""
            
            self.total_signals_sent += 1
            
            return {
                'symbol': symbol,
                'asset_type': asset_type,
                'preentry_message': preentry_message,
                'signal_message': signal_message,
                'preentry_delay': timing['seconds_until_preentry'],
                'main_delay': timing['seconds_until_next_candle'],
                'direction': direction,
                'confidence': confidence,
                'entry_time': entry_time_str
            }
            
        except Exception as e:
            print(f"‚ùå Signal generation error: {e}")
            return await self.generate_signal("EUR/USD")

    async def start_signals(self, user_id: int, application):
        """Start signal generation with admin approval check"""
        if not self.is_user_approved(user_id):
            return "‚ùå **ACCESS DENIED**\n\nYour account is pending approval. Please wait for admin approval to start receiving signals."
        
        if user_id in active_users:
            return "‚ùå Signals already running!"
        
        user_status = "üõ°Ô∏è ADMIN" if self.is_admin(user_id) else "üë§ USER"
        print(f"üöÄ Starting signals for {user_status} {user_id}")
        active_users.add(user_id)
        user_start_times[user_id] = time.time()
        
        # Start the signal loop
        task = asyncio.create_task(self.admin_signal_loop(user_id, application))
        self.user_loops[user_id] = task
        
        welcome_text = """üöÄ **PREMIUM SIGNALS ACTIVATED!**

‚úÖ **Approved User Access**
‚è∞ **5-Minute Candle Entries**
üéØ **Pre-entry Alerts:** 40s before new candle
üìä **Signal Interval:** 1-3 minutes
üîÑ **All signals on new 5M candles**"""
        
        if self.is_admin(user_id):
            welcome_text += "\n\nüõ°Ô∏è **ADMIN PRIVILEGES ACTIVATED**"
        
        welcome_text += """

**üéØ SELECTED MARKETS:**
‚Ä¢ üåç 10 Major Forex Pairs
‚Ä¢ ‚Çø 10 Top Cryptocurrencies  
‚Ä¢ üí∞ 5 Key Commodities
‚Ä¢ üè¢ 10 Blue-Chip Stocks

**Next signal within 1-3 minutes...** üöÄ"""
        
        return welcome_text

    async def stop_signals(self, user_id: int):
        """Stop signals with proper cleanup"""
        print(f"üõë Stopping signals for user {user_id}")
        active_users.discard(user_id)
        
        if user_id in user_start_times:
            del user_start_times[user_id]
        
        if user_id in self.user_loops:
            task = self.user_loops[user_id]
            if not task.done():
                task.cancel()
                try:
                    await task
                except asyncio.CancelledError:
                    pass
            del self.user_loops[user_id]
        
        return "üõë Signals stopped."

    async def admin_signal_loop(self, user_id: int, application):
        """Signal loop for approved users with 5-minute candles"""
        try:
            await asyncio.sleep(1)
            
            user_status = "ADMIN" if self.is_admin(user_id) else "USER"
            print(f"üéØ Starting signal loop for {user_status} {user_id}")
            
            # Send welcome message
            welcome_msg = """üéØ **PREMIUM 5M TRADING BOT**

‚ö° **APPROVED USER FEATURES:**
‚Ä¢ All entries on new 5-minute candles
‚Ä¢ Pre-entry alerts 40 seconds before
‚Ä¢ Premium asset selection
‚Ä¢ Next signal within 1-3 minutes"""
            
            if self.is_admin(user_id):
                welcome_msg += "\n‚Ä¢ üõ°Ô∏è **ADMIN PRIVILEGES ACTIVE**"
            
            welcome_msg += """
üìä **SELECTED ASSETS:**
‚Ä¢ EUR/USD, GBP/USD, USD/JPY, Gold, Oil
‚Ä¢ BTC, ETH, XRP, ADA, SOL
‚Ä¢ AAPL, TSLA, AMZN, NVDA, and more

‚è∞ **5-MINUTE STRATEGY:**
Trade the new 5-minute candle formation for optimal entries!

**Next signal within 1-3 minutes...** üïí"""
            
            await self.safe_send_message(user_id, application, welcome_msg)
            
            consecutive_errors = 0
            
            while user_id in active_users and self.is_user_approved(user_id):
                try:
                    # Select random asset from optimized watchlist
                    symbol = random.choice(WATCHLIST)
                    
                    # Generate signal with new candle timing
                    signal_data = await self.generate_signal(symbol)
                    
                    if signal_data:
                        # Send pre-entry message (40s before new candle)
                        if signal_data['preentry_delay'] > 0:
                            await asyncio.sleep(signal_data['preentry_delay'])
                            await self.safe_send_message(user_id, application, signal_data['preentry_message'])
                        
                        # Send main signal at new candle
                        if signal_data['main_delay'] > 0:
                            await asyncio.sleep(signal_data['main_delay'] - signal_data['preentry_delay'])
                            await self.safe_send_message(user_id, application, signal_data['signal_message'])
                        
                        consecutive_errors = 0
                        print(f"‚úÖ {user_status} {user_id}: 5M signal for {symbol} at {signal_data['entry_time']}")
                    
                    # Wait before next signal (1-3 minutes)
                    wait_time = random.randint(MIN_SIGNAL_COOLDOWN, MAX_SIGNAL_COOLDOWN)
                    print(f"‚è∞ {user_status} {user_id}: Next signal in {wait_time}s")
                    
                    # Check every second if we should stop
                    for _ in range(wait_time):
                        if user_id not in active_users or not self.is_user_approved(user_id):
                            break
                        await asyncio.sleep(1)
                    
                except Exception as e:
                    consecutive_errors += 1
                    print(f"‚ùå Signal loop error for user {user_id}: {e}")
                    
                    if consecutive_errors >= 3:
                        print(f"üö® Too many errors for user {user_id}, stopping...")
                        await self.stop_signals(user_id)
                        break
                    
                    await asyncio.sleep(10)
                    
        except asyncio.CancelledError:
            print(f"üîö Signal loop cancelled for user {user_id}")
        except Exception as e:
            print(f"üí• FATAL: Signal loop crashed for user {user_id}: {e}")
            await self.stop_signals(user_id)

# Initialize ADMIN bot
trading_bot = AdminTradingBot()

# ------------------ ADMIN KEYBOARD ------------------
def get_main_keyboard(user_id: int):
    keyboard = [
        [InlineKeyboardButton("üöÄ START SIGNALS", callback_data="start_signals")],
        [InlineKeyboardButton("üõë STOP SIGNALS", callback_data="stop_signals")],
        [InlineKeyboardButton("üìä LIVE STATS", callback_data="live_stats"),
         InlineKeyboardButton("üéØ ASSETS", callback_data="show_assets")]
    ]
    
    # Add admin panel button for admins
    if user_id in ADMIN_IDS:
        keyboard.append([InlineKeyboardButton("üëë ADMIN PANEL", callback_data="admin_panel")])
    
    return InlineKeyboardMarkup(keyboard)

# ------------------ ADMIN HANDLERS ------------------
async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Start command with admin approval check"""
    try:
        user = update.effective_user
        trading_bot.add_user(user.id, user.username)
        
        is_admin = user.id in ADMIN_IDS
        is_approved = trading_bot.is_user_approved(user.id)
        
        if is_admin:
            welcome_text = """
üéØ **PREMIUM 5M TRADING BOT** ‚ö°

**üõ°Ô∏è ADMINISTRATOR ACCESS**
**‚ö° FULL PRIVILEGES:**
‚Ä¢ All premium signals
‚Ä¢ Admin control panel
‚Ä¢ User management
‚Ä¢ Auto-approved access

**üìä SELECTED MARKETS:**
‚Ä¢ 10 Major Forex Pairs
‚Ä¢ 10 Top Cryptocurrencies  
‚Ä¢ 5 Key Commodities
‚Ä¢ 10 Blue-Chip Stocks

**‚è∞ 5-MINUTE STRATEGY:**
Trade new 5-minute candle formations for optimal entries!

**üöÄ START TRADING:**
Click below to begin 5-minute trading!
"""
        elif is_approved:
            welcome_text = """
üéØ **PREMIUM 5M TRADING BOT** ‚ö°

**‚úÖ APPROVED USER ACCESS**
**‚ö° PREMIUM FEATURES:**
‚Ä¢ All signals on new 5-minute candles
‚Ä¢ Pre-entry alerts 40 seconds before
‚Ä¢ Optimized asset selection
‚Ä¢ Next signal within 1-3 minutes

**üöÄ START TRADING:**
Click below to begin 5-minute trading!
"""
        else:
            welcome_text = """
üéØ **PREMIUM 5M TRADING BOT** ‚ö°

**‚è≥ PENDING APPROVAL**
Thank you for registering! Your account is currently **pending admin approval**.

**üìã WHAT TO EXPECT:**
‚Ä¢ Premium 5-minute candle signals
‚Ä¢ 40-second pre-entry alerts  
‚Ä¢ 1-3 minute signal intervals
‚Ä¢ All major markets

**‚úÖ APPROVAL PROCESS:**
You will be notified once your account is approved by admin.

**Please wait for approval confirmation...** ‚è∞
"""
        
        await update.message.reply_text(
            welcome_text, 
            reply_markup=get_main_keyboard(user.id),
            parse_mode='Markdown'
        )
        
        user_type = "ADMIN" if is_admin else "APPROVED USER" if is_approved else "PENDING USER"
        print(f"‚úÖ Start command for {user_type} {user.id}")
        
    except Exception as e:
        print(f"‚ùå Start command error: {e}")
        await update.message.reply_text("Error starting bot. Please try again.")

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Button handler with admin approval check"""
    try:
        query = update.callback_query
        user_id = query.from_user.id
        
        await query.answer()
        
        print(f"üéÆ Button pressed: {query.data} by user {user_id}")
        
        if query.data == "start_signals":
            result = await trading_bot.start_signals(user_id, context.application)
            await query.edit_message_text(result, reply_markup=get_main_keyboard(user_id))
            
        elif query.data == "stop_signals":
            result = await trading_bot.stop_signals(user_id)
            await query.edit_message_text(result, reply_markup=get_main_keyboard(user_id))
            
        elif query.data == "live_stats":
            await show_live_stats(query, user_id)
            
        elif query.data == "show_assets":
            await show_assets_handler(query, user_id)
            
        elif query.data == "admin_panel":
            if user_id in ADMIN_IDS:
                await show_admin_panel(query)
            else:
                await query.edit_message_text("‚ùå Admin access required.", reply_markup=get_main_keyboard(user_id))
            
    except Exception as e:
        print(f"‚ùå Button handler error: {e}")
        try:
            await query.edit_message_text("‚ùå Error. Please try /start again.", reply_markup=get_main_keyboard(user_id))
        except:
            pass

async def show_live_stats(query, user_id):
    """Show live statistics"""
    try:
        is_running = user_id in active_users
        is_approved = trading_bot.is_user_approved(user_id)
        is_admin = user_id in ADMIN_IDS
        running_time = 0
        
        if user_id in user_start_times:
            running_time = time.time() - user_start_times[user_id]
        
        stats_text = f"""
üìä **LIVE STATISTICS**

**üë§ USER STATUS:**
‚Ä¢ Account: {'üõ°Ô∏è ADMIN' if is_admin else '‚úÖ APPROVED' if is_approved else '‚è≥ PENDING'}
‚Ä¢ Signals: {'‚úÖ RUNNING' if is_running else '‚ùå STOPPED'}
‚Ä¢ Running Time: {int(running_time/60)} minutes

**üìà ASSET DISTRIBUTION:**
‚Ä¢ Forex Pairs: {len(POCKET_MAJOR_FOREX)}
‚Ä¢ Cryptocurrencies: {len(POCKET_CRYPTO)}
‚Ä¢ Commodities: {len(POCKET_COMMODITIES)}
‚Ä¢ Stocks: {len(POCKET_STOCKS)}

**‚ö° SYSTEM:**
‚Ä¢ Signal Timing: New 5M Candles
‚Ä¢ Pre-entry Alert: 40s before
‚Ä¢ Next Signal: Within 1-3 minutes
‚Ä¢ Strategy: 5M Candle Breakout

**üéØ NEXT SIGNAL:** {'Within 1-3 minutes' if is_approved else 'After approval'}
"""
        
        await query.edit_message_text(stats_text, reply_markup=get_main_keyboard(user_id), parse_mode='Markdown')
        
    except Exception as e:
        print(f"‚ùå Stats error: {e}")
        await query.edit_message_text("Error loading stats.", reply_markup=get_main_keyboard(user_id))

async def show_assets_handler(query, user_id):
    """Show optimized asset list"""
    try:
        is_approved = trading_bot.is_user_approved(user_id)
        
        assets_text = f"""
üéØ **PREMIUM ASSET SELECTION**

**üí± FOREX ({len(POCKET_MAJOR_FOREX)} pairs):**
{', '.join(POCKET_MAJOR_FOREX)}

**‚Çø CRYPTO ({len(POCKET_CRYPTO)} coins):**
{', '.join(POCKET_CRYPTO)}

**üí∞ COMMODITIES ({len(POCKET_COMMODITIES)}):**
{', '.join(POCKET_COMMODITIES)}

**üè¢ STOCKS ({len(POCKET_STOCKS)}):**
{', '.join(POCKET_STOCKS)}

**üìä Total: {len(WATCHLIST)} premium assets**
**‚è∞ Timeframe: 5 Minutes**
**üîÑ Next signal: {'Within 1-3 minutes' if is_approved else 'After approval'}** üïí
"""
        
        await query.edit_message_text(assets_text, reply_markup=get_main_keyboard(user_id), parse_mode='Markdown')
        
    except Exception as e:
        print(f"‚ùå Assets error: {e}")
        await query.edit_message_text("Error loading assets.", reply_markup=get_main_keyboard(user_id))

async def show_admin_panel(query):
    """Show admin panel"""
    try:
        admin_text = """
üëë **ADMIN CONTROL PANEL**

**üõ†Ô∏è QUICK ACTIONS:**
‚Ä¢ Use `/subscribers` - View all users
‚Ä¢ Use `/approve USER_ID` - Approve users
‚Ä¢ Use `/stats` - Bot statistics

**üìä REAL-TIME STATS:"""
        
        subscribers = trading_bot.get_all_subscribers()
        total_users = len(subscribers)
        approved_users = sum(1 for s in subscribers if s['approved'])
        pending_users = total_users - approved_users
        active_now = len(active_users)
        
        admin_text += f"""
‚Ä¢ Total Users: {total_users}
‚Ä¢ Approved: {approved_users}
‚Ä¢ Pending: {pending_users}
‚Ä¢ Active Now: {active_now}
‚Ä¢ Total Signals: {trading_bot.total_signals_sent}

**‚ö° ADMIN IDS:**
"""
        
        for admin_id in ADMIN_IDS:
            admin_text += f"‚Ä¢ `{admin_id}`\n"
        
        admin_text += "\n**Use commands in chat for full control.**"
        
        await query.edit_message_text(admin_text, reply_markup=get_main_keyboard(query.from_user.id), parse_mode='Markdown')
        
    except Exception as e:
        print(f"‚ùå Admin panel error: {e}")
        await query.edit_message_text("Error loading admin panel.", reply_markup=get_main_keyboard(query.from_user.id))

# ------------------ ADMIN COMMANDS ------------------
async def admin_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Admin command handler"""
    try:
        user_id = update.effective_user.id
        
        # Check if user is admin
        if user_id not in ADMIN_IDS:
            await update.message.reply_text("‚ùå Access denied. Admin only.")
            return
        
        if not context.args:
            admin_help = """
üëë **ADMIN COMMANDS**

**User Management:**
‚Ä¢ /subscribers - View all subscribers
‚Ä¢ /approve <user_id> - Approve a user
‚Ä¢ /stats - Bot statistics

**Examples:**
‚Ä¢ `/subscribers` - List all users
‚Ä¢ `/approve 123456789` - Approve user
‚Ä¢ `/stats` - View bot stats
"""
            await update.message.reply_text(admin_help, parse_mode='Markdown')
            return
        
        command = context.args[0].lower()
        
        if command == "subscribers":
            await show_subscribers(update, context)
        elif command == "approve":
            await approve_user(update, context)
        elif command == "stats":
            await admin_stats(update, context)
        else:
            await update.message.reply_text("‚ùå Unknown admin command.")
            
    except Exception as e:
        print(f"‚ùå Admin command error: {e}")
        await update.message.reply_text("‚ùå Admin command error.")

async def show_subscribers(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show all subscribers to admin"""
    try:
        subscribers = trading_bot.get_all_subscribers()
        
        if not subscribers:
            await update.message.reply_text("üì≠ No subscribers found.")
            return
        
        total_users = len(subscribers)
        approved_users = sum(1 for s in subscribers if s['approved'])
        pending_users = total_users - approved_users
        
        subscribers_text = f"""
üë• **SUBSCRIBER MANAGEMENT**

**üìä OVERVIEW:**
‚Ä¢ Total Users: {total_users}
‚Ä¢ Approved: {approved_users}
‚Ä¢ Pending: {pending_users}

**üìã USER LIST:**
"""
        
        for i, sub in enumerate(subscribers[:20], 1):  # Show first 20 users
            status_emoji = "üõ°Ô∏è" if sub['is_admin'] else "‚úÖ" if sub['approved'] else "‚è≥"
            status_text = "ADMIN" if sub['is_admin'] else "APPROVED" if sub['approved'] else "PENDING"
            subscribers_text += f"\n{i}. {sub['username']} (ID: `{sub['chat_id']}`) {status_emoji}"
            subscribers_text += f"\n   üìÖ Joined: {sub['join_date'][:10]}"
            subscribers_text += f"\n   üìä Status: {status_text}\n"
        
        if len(subscribers) > 20:
            subscribers_text += f"\n... and {len(subscribers) - 20} more users"
        
        subscribers_text += f"\n\n**Use:** `/approve USER_ID` to approve users"
        
        await update.message.reply_text(subscribers_text, parse_mode='Markdown')
        
    except Exception as e:
        print(f"‚ùå Show subscribers error: {e}")
        await update.message.reply_text("‚ùå Error loading subscribers.")

async def approve_user(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Approve a user"""
    try:
        if len(context.args) < 2:
            await update.message.reply_text("‚ùå Usage: /approve <user_id>")
            return
        
        user_id_to_approve = int(context.args[1])
        
        # Don't allow approving admins (they're auto-approved)
        if user_id_to_approve in ADMIN_IDS:
            await update.message.reply_text("‚ÑπÔ∏è Admin users are automatically approved.")
            return
        
        if trading_bot.approve_user(user_id_to_approve):
            # Notify the approved user if possible
            try:
                await context.bot.send_message(
                    chat_id=user_id_to_approve,
                    text="üéâ **ACCOUNT APPROVED!**\n\nYour account has been approved by admin. You can now start receiving premium 5-minute trading signals!\n\nUse /start to begin trading! üöÄ",
                    parse_mode='Markdown'
                )
            except Exception as e:
                print(f"‚ö†Ô∏è Could not notify user {user_id_to_approve}: {e}")
            
            await update.message.reply_text(f"‚úÖ User `{user_id_to_approve}` approved successfully!", parse_mode='Markdown')
        else:
            await update.message.reply_text(f"‚ùå Failed to approve user `{user_id_to_approve}`", parse_mode='Markdown')
            
    except ValueError:
        await update.message.reply_text("‚ùå Invalid user ID. Please provide a numeric user ID.")
    except Exception as e:
        print(f"‚ùå Approve user error: {e}")
        await update.message.reply_text("‚ùå Error approving user.")

async def admin_stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show admin statistics"""
    try:
        subscribers = trading_bot.get_all_subscribers()
        total_users = len(subscribers)
        approved_users = sum(1 for s in subscribers if s['approved'])
        active_now = len(active_users)
        
        stats_text = f"""
üëë **ADMIN STATISTICS**

**üìä USER STATS:**
‚Ä¢ Total Subscribers: {total_users}
‚Ä¢ Approved Users: {approved_users}
‚Ä¢ Pending Approval: {total_users - approved_users}
‚Ä¢ Active Now: {active_now}
‚Ä¢ Admin Users: {len(ADMIN_IDS)}

**üöÄ PERFORMANCE:**
‚Ä¢ Total Signals Sent: {trading_bot.total_signals_sent}
‚Ä¢ Active Signal Loops: {len(trading_bot.user_loops)}

**üìà ASSETS:**
‚Ä¢ Total Assets: {len(WATCHLIST)}
‚Ä¢ Forex: {len(POCKET_MAJOR_FOREX)}
‚Ä¢ Crypto: {len(POCKET_CRYPTO)}
‚Ä¢ Commodities: {len(POCKET_COMMODITIES)}
‚Ä¢ Stocks: {len(POCKET_STOCKS)}

**üõ°Ô∏è ADMIN IDS:**
"""
        
        for admin_id in ADMIN_IDS:
            stats_text += f"‚Ä¢ `{admin_id}`\n"
            
        stats_text += """
**‚ö° SYSTEM:**
‚Ä¢ Timeframe: 5 Minutes
‚Ä¢ Signal Interval: 1-3 minutes
‚Ä¢ Pre-entry: 40s before
‚Ä¢ Status: ‚úÖ Operational
"""
        
        await update.message.reply_text(stats_text, parse_mode='Markdown')
        
    except Exception as e:
        print(f"‚ùå Admin stats error: {e}")
        await update.message.reply_text("‚ùå Error loading admin stats.")

# ------------------ BOT SETUP ------------------
def setup_bot_application():
    """Setup bot with proper handlers"""
    application = Application.builder().token(BOT_TOKEN).build()
    
    # Add command handlers
    application.add_handler(CommandHandler("start", start_command))
    application.add_handler(CommandHandler("admin", admin_command))
    application.add_handler(CallbackQueryHandler(button_handler))
    
    print("‚úÖ Bot application setup complete")
    return application

# Create bot application
bot_app = setup_bot_application()

# ------------------ MAIN APPLICATION ------------------
async def main_application():
    """Main application entry point"""
    restart_count = 0
    max_restarts = 10
    
    while restart_count < max_restarts:
        try:
            print(f"üöÄ Starting Admin Trading Bot... (Attempt {restart_count + 1})")
            
            # Initialize session
            await trading_bot.init_session()
            
            # Start HTTP server in background
            try:
                server_thread = threading.Thread(target=start_http_server, daemon=True)
                server_thread.start()
                print("‚úÖ HTTP server started")
            except Exception as e:
                print(f"‚ùå HTTP server error: {e}")
            
            # Start the bot
            await bot_app.initialize()
            await bot_app.start()
            await bot_app.updater.start_polling()
            
            print("ü§ñ ADMIN TRADING BOT IS NOW LIVE!")
            print(f"üìä Total Assets: {len(WATCHLIST)}")
            print("‚úÖ All signals on new 5M candles")
            print("‚úÖ Admin approval system")
            print("‚úÖ Subscriber management")
            print("‚úÖ Next signal within 1-3 minutes")
            print(f"üõ°Ô∏è Admin IDs: {ADMIN_IDS}")
            print("‚úÖ Port:", HTTP_PORT)
            
            # Reset restart count on success
            restart_count = 0
            
            # Keep the application running
            await asyncio.Future()  # Run forever
            
        except Exception as e:
            restart_count += 1
            print(f"‚ùå Bot crashed: {e}")
            print(f"üîÑ Restarting in 30 seconds... ({restart_count}/{max_restarts})")
            
            # Cleanup
            try:
                await bot_app.updater.stop()
                await bot_app.stop()
                await bot_app.shutdown()
            except:
                pass
            
            if restart_count >= max_restarts:
                print("üö® Maximum restart attempts reached. Bot stopped.")
                break
                
            await asyncio.sleep(30)

if __name__ == "__main__":
    print("=" * 50)
    print("üéØ ADMIN TRADING BOT - 5M CANDLE STRATEGY")
    print(f"üìä TOTAL ASSETS: {len(WATCHLIST)}")
    print(f"üõ°Ô∏è ADMIN IDS: {ADMIN_IDS}")
    print("üåç 10 Major Forex Pairs")
    print("‚Çø 10 Top Cryptocurrencies")
    print("üí∞ 5 Key Commodities") 
    print("üè¢ 10 Blue-Chip Stocks")
    print("‚è∞ All signals on new 5M candles")
    print("‚úÖ Pre-entry: 40s before new candle")
    print("‚úÖ Next signal: Within 1-3 minutes")
    print("‚úÖ Admin approval system")
    print("‚úÖ Subscriber management")
    print("=" * 50)
    
    # Run the main bot application
    asyncio.run(main_application())
